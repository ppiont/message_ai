---
description: Testing guidelines and TDD practices for Flutter/Dart development
alwaysApply: true
---

# Testing Guidelines - Test-Driven Development

## **CRITICAL: Test-First Development**

Following strict TDD methodology for all new features and bug fixes.

### Test Hierarchy

**Unit Tests** (domain/data layers):
- Test entities, models, use cases, repositories
- Mock external dependencies
- Fast, isolated, no side effects
- Location: `test/features/{feature}/domain/` and `test/features/{feature}/data/`

**Widget Tests** (presentation layer):
- Test individual widgets in isolation
- Mock providers and dependencies
- Verify UI behavior and state changes
- Location: `test/features/{feature}/presentation/widgets/`

**Integration Tests** (feature flows):
- Test complete features end-to-end
- Use real providers with mocked data sources
- Verify data flow through all layers
- Location: `test/features/{feature}/integration/`

## **TDD Cycle (RED-GREEN-REFACTOR)**

### 1. RED Phase: Write Failing Test First
```dart
// ❌ Example: Write test BEFORE implementation
test('should create conversation with valid participants', () async {
  // Arrange
  final participant1 = Participant(uid: 'user1', name: 'User 1', preferredLanguage: 'en');
  final participant2 = Participant(uid: 'user2', name: 'User 2', preferredLanguage: 'en');

  // Act
  final result = await useCase(
    userId1: 'user1',
    userId2: 'user2',
    user1Participant: participant1,
    user2Participant: participant2,
  );

  // Assert
  expect(result.isRight(), true);
  result.fold(
    (failure) => fail('Should not fail'),
    (conversation) {
      expect(conversation.participants.length, 2);
      expect(conversation.type, 'direct');
    },
  );
});
```

### 2. GREEN Phase: Implement Minimum Code
```dart
// ✅ Write just enough code to make test pass
class FindOrCreateDirectConversation {
  Future<Either<Failure, Conversation>> call(...) async {
    // Minimal implementation
    final conversation = Conversation(...);
    return Right(conversation);
  }
}
```

### 3. REFACTOR Phase: Clean Up
```dart
// ✅ Improve code quality while keeping tests green
class FindOrCreateDirectConversation {
  Future<Either<Failure, Conversation>> call(...) async {
    // Validate inputs
    if (userId1 == userId2) {
      return Left(ValidationFailure(...));
    }

    // Check for existing conversation
    final existing = await _findExisting();
    if (existing != null) return Right(existing);

    // Create new conversation
    return _createNew();
  }
}
```

## **When to Write Tests**

### ✅ ALWAYS Test Before Implementation

**New Features:**
1. Write use case tests first
2. Write repository tests
3. Write data source tests
4. Write widget tests (if UI involved)
5. Then implement

**Bug Fixes:**
1. Write test that reproduces the bug (fails)
2. Fix the bug
3. Verify test passes
4. Add additional edge case tests

**Refactoring:**
1. Ensure existing tests cover behavior
2. Add tests for uncovered areas
3. Refactor with green tests
4. Verify all tests still pass

### ❌ NEVER Skip Tests For

- Domain entities and value objects
- Use cases (business logic)
- Repositories (data orchestration)
- Data sources (external I/O)
- Complex widgets with state
- Data models (serialization/deserialization)

### ⚠️ Optional Tests (but recommended)

- Simple stateless widgets (pure UI)
- Generated code (providers, models)
- Configuration files

## **Testing Tools & Frameworks**

### Required Dependencies

```yaml
dev_dependencies:
  flutter_test:
    sdk: flutter
  mocktail: ^1.0.4           # Mocking
  fake_cloud_firestore: ^3.0.3  # Firebase mocks
  firebase_auth_mocks: ^0.14.1  # Auth mocks
```

### Mocking with Mocktail

```dart
// ✅ Create mocks for external dependencies
class MockAuthRepository extends Mock implements AuthRepository {}
class MockFirestore extends Mock implements FirebaseFirestore {}

// ✅ Setup mock behavior
when(() => mockRepo.getCurrentUser())
    .thenAnswer((_) async => Right(testUser));

// ✅ Verify interactions
verify(() => mockRepo.signOut()).called(1);
```

### Testing Riverpod Providers

```dart
// ✅ Use ProviderContainer for testing
test('authStateProvider should emit user on sign in', () {
  final container = ProviderContainer(
    overrides: [
      authRepositoryProvider.overrideWithValue(mockAuthRepository),
    ],
  );

  final listener = Listener<AsyncValue<User?>>();

  container.listen(
    authStateProvider,
    listener,
    fireImmediately: true,
  );

  verify(() => listener(null, any())).called(1);
});
```

## **Test Structure Standards**

### AAA Pattern (Arrange-Act-Assert)

```dart
test('should return failure when email is invalid', () {
  // Arrange
  const invalidEmail = 'not-an-email';
  const password = 'password123';

  // Act
  final result = await useCase(email: invalidEmail, password: password);

  // Assert
  expect(result.isLeft(), true);
  result.fold(
    (failure) => expect(failure, isA<ValidationFailure>()),
    (_) => fail('Should not succeed'),
  );
});
```

### Group Related Tests

```dart
group('SignUpWithEmail', () {
  late SignUpWithEmail useCase;
  late MockAuthRepository mockRepository;

  setUp(() {
    mockRepository = MockAuthRepository();
    useCase = SignUpWithEmail(mockRepository);
  });

  group('validation', () {
    test('should fail when email is empty', () async { ... });
    test('should fail when email is invalid', () async { ... });
    test('should fail when password is too short', () async { ... });
  });

  group('success cases', () {
    test('should return user when credentials are valid', () async { ... });
    test('should sync user to Firestore after signup', () async { ... });
  });

  group('error cases', () {
    test('should return failure when email already exists', () async { ... });
    test('should return failure when network is unavailable', () async { ... });
  });
});
```

## **Test Coverage Goals**

### Minimum Coverage Requirements

- **Domain Layer**: 100% (pure business logic)
- **Data Layer**: 90%+ (I/O operations)
- **Presentation Layer**: 80%+ (UI logic)
- **Overall Project**: 85%+

### Check Coverage

```bash
# Run tests with coverage
flutter test --coverage

# Generate HTML report
genhtml coverage/lcov.info -o coverage/html

# Open report
open coverage/html/index.html
```

## **Common Testing Patterns**

### Testing Use Cases

```dart
// ✅ Test happy path
test('should execute successfully with valid input', () async { ... });

// ✅ Test validation
test('should return ValidationFailure for invalid input', () async { ... });

// ✅ Test error handling
test('should return ServerFailure when server error occurs', () async { ... });

// ✅ Test edge cases
test('should handle empty results gracefully', () async { ... });
```

### Testing Repositories

```dart
// ✅ Test data source coordination
test('should call remote data source and return mapped entity', () async { ... });

// ✅ Test error mapping
test('should map ServerException to ServerFailure', () async { ... });

// ✅ Test caching logic (if applicable)
test('should return cached data when offline', () async { ... });
```

### Testing Data Sources

```dart
// ✅ Test successful operations
test('should return model when Firestore document exists', () async { ... });

// ✅ Test error scenarios
test('should throw NotFoundException when document missing', () async { ... });

// ✅ Test serialization
test('should correctly serialize model to Firestore format', () async { ... });
test('should correctly deserialize Firestore data to model', () async { ... });
```

### Testing Widgets

```dart
testWidgets('should display error message when login fails', (tester) async {
  // Arrange
  final mockRepo = MockAuthRepository();
  when(() => mockRepo.signIn(any(), any()))
      .thenAnswer((_) async => Left(ServerFailure('Connection error')));

  await tester.pumpWidget(
    ProviderScope(
      overrides: [
        authRepositoryProvider.overrideWithValue(mockRepo),
      ],
      child: const MaterialApp(home: SignInPage()),
    ),
  );

  // Act
  await tester.enterText(find.byKey(const Key('email_field')), 'test@test.com');
  await tester.enterText(find.byKey(const Key('password_field')), 'password');
  await tester.tap(find.byKey(const Key('sign_in_button')));
  await tester.pumpAndSettle();

  // Assert
  expect(find.text('Connection error'), findsOneWidget);
});
```

## **Anti-Patterns to Avoid**

### ❌ DON'T: Test Implementation Details

```dart
// ❌ BAD: Testing internal state
test('should call _privateMethod', () { ... });

// ✅ GOOD: Test observable behavior
test('should return correct result', () { ... });
```

### ❌ DON'T: Write Tests After Implementation

```dart
// ❌ BAD: Implement first, test later
// This often leads to:
// - Untestable code
// - Missing edge cases
// - Incomplete coverage

// ✅ GOOD: Test first, implement second
// Benefits:
// - Better design
// - Complete coverage
// - Confidence in changes
```

### ❌ DON'T: Skip Tests for "Simple" Code

```dart
// ❌ BAD: "This getter is too simple to test"
String get displayName => firstName + ' ' + lastName;

// ✅ GOOD: Even simple code can have edge cases
test('should handle empty firstName', () {
  final user = User(firstName: '', lastName: 'Smith');
  expect(user.displayName, ' Smith'); // Unexpected space!
});
```

### ❌ DON'T: Mock Everything

```dart
// ❌ BAD: Over-mocking makes tests brittle
final mockString = MockString();
when(() => mockString.length).thenReturn(5);

// ✅ GOOD: Use real objects when simple
final string = 'hello';
expect(string.length, 5);
```

## **Test Organization**

### Directory Structure

```
test/
├── features/
│   ├── authentication/
│   │   ├── domain/
│   │   │   ├── entities/
│   │   │   │   └── user_test.dart
│   │   │   └── usecases/
│   │   │       ├── sign_in_with_email_test.dart
│   │   │       ├── sign_up_with_email_test.dart
│   │   │       └── sign_out_test.dart
│   │   ├── data/
│   │   │   ├── models/
│   │   │   │   └── user_model_test.dart
│   │   │   ├── datasources/
│   │   │   │   └── auth_remote_datasource_test.dart
│   │   │   └── repositories/
│   │   │       └── auth_repository_impl_test.dart
│   │   ├── presentation/
│   │   │   ├── pages/
│   │   │   │   ├── sign_in_page_test.dart
│   │   │   │   └── sign_up_page_test.dart
│   │   │   └── widgets/
│   │   │       └── auth_button_test.dart
│   │   └── integration/
│   │       └── authentication_flow_test.dart
│   └── messaging/
│       └── ... (same structure)
├── core/
│   ├── error/
│   │   ├── error_mapper_test.dart
│   │   └── error_logger_test.dart
│   └── network/
│       └── network_info_test.dart
└── helpers/
    ├── test_helpers.dart
    └── mock_data.dart
```

### Test Helpers

```dart
// test/helpers/test_helpers.dart
const testUser = User(
  uid: 'test-uid',
  email: 'test@test.com',
  displayName: 'Test User',
  preferredLanguage: 'en',
  createdAt: DateTime(2024, 1, 1),
  lastSeen: DateTime(2024, 1, 1),
  isOnline: true,
  fcmTokens: [],
);

ProviderContainer createContainer({
  List<Override> overrides = const [],
}) {
  return ProviderContainer(overrides: overrides);
}
```

## **Running Tests**

### Command Line

```bash
# Run all tests
flutter test

# Run specific test file
flutter test test/features/auth/domain/usecases/sign_in_test.dart

# Run tests matching name pattern
flutter test --name "sign in"

# Run tests with coverage
flutter test --coverage

# Watch mode (re-run on changes)
flutter test --watch
```

### CI/CD Integration

```yaml
# .github/workflows/test.yml
name: Tests
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: subosito/flutter-action@v2
      - run: flutter pub get
      - run: flutter test --coverage
      - run: flutter test --coverage --minimum-coverage 85
```

## **Enforcing TDD**

### Pre-Commit Hook

```bash
# .git/hooks/pre-commit
#!/bin/bash
echo "Running tests before commit..."
flutter test
if [ $? -ne 0 ]; then
  echo "Tests failed. Commit aborted."
  exit 1
fi
```

### Code Review Checklist

- [ ] Tests written before implementation
- [ ] All tests pass
- [ ] Coverage meets minimum requirements
- [ ] Tests follow AAA pattern
- [ ] Mocks are used appropriately
- [ ] Edge cases are covered
- [ ] Error scenarios are tested

## **References**

- [Flutter Testing Docs](https://flutter.dev/docs/testing)
- [Mocktail Package](https://pub.dev/packages/mocktail)
- [TDD by Example](https://www.amazon.com/Test-Driven-Development-Kent-Beck/dp/0321146530)
- [Clean Architecture Testing](https://blog.cleancoder.com/uncle-bob/2017/03/03/TDD-Harms-Architecture.html)

## **Next Steps for Current Project**

**Immediate Actions:**
1. Audit existing code for missing tests
2. Write tests for recently implemented features:
   - Conversation creation/retrieval
   - Message sending
   - User selection
   - Firestore sync
3. Set up coverage reporting
4. Add pre-commit hooks
5. Document test patterns in this rule

**Going Forward:**
- Write tests FIRST for all new features
- Use RED-GREEN-REFACTOR cycle
- Maintain 85%+ coverage
- Review test quality in PRs
