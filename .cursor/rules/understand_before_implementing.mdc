---
description: Always understand existing architecture before implementing new features
globs: lib/**/*.dart, test/**/*.dart
alwaysApply: true
---

# Understand Before Implementing

## **CRITICAL RULE: Never Implement Blindly**

Before implementing ANY new feature, service, or component, you MUST:

### 1. **Examine Existing Patterns**
```dart
// ❌ DON'T: Start coding immediately
// "I'll create a sync service that uses data sources..."

// ✅ DO: First understand the architecture
// 1. Read existing similar components
// 2. Understand data flow (Entity → Model → Firestore)
// 3. Check how other services/repositories work
// 4. Identify patterns for error handling, conversion, etc.
```

### 2. **Understand the Data Layer**
- **Domain Layer**: Uses Entities (e.g., `Message`, `Conversation`)
- **Data Layer**: Uses Models (e.g., `MessageModel`, `ConversationModel`)
- **Repositories**: Handle Entity ↔ Model conversion
- **Data Sources**: Work with Models (local with entities via DAOs, remote with models)

### 3. **Check Method Signatures**
```dart
// ❌ DON'T: Assume method names
when(() => dataSource.getMessage(...))  // Might not exist!

// ✅ DO: Read the actual interface
// 1. Open the data source file
// 2. Read the abstract interface
// 3. Check parameter types (Model vs Entity)
// 4. Verify return types
```

### 4. **Follow Existing Patterns**
- If repositories handle Model/Entity conversion → use repositories
- If services work at domain level → use entities
- If data sources work at data level → use models
- **Never mix layers incorrectly**

### 5. **Architecture Understanding Checklist**

Before implementing, answer these questions:
- [ ] What layer am I working in? (Domain/Data/Presentation)
- [ ] What do existing similar components do?
- [ ] How do they handle data conversion?
- [ ] What error handling patterns are used?
- [ ] What testing patterns are established?
- [ ] Are there naming conventions I should follow?

### 6. **Red Flags That You're Going Blind**
- "I'll just try this method name..."
- "It should probably work like this..."
- "I'm not sure if this exists but..."
- "Let's see what errors we get..."
- Compilation errors for method signatures
- Type mismatches between layers

### 7. **Correct Development Flow**

```mermaid
flowchart TD
    Start[New Feature Request]
    Understand[Read Existing Code]
    Pattern[Identify Patterns]
    Design[Design Solution]
    Implement[Implement]
    Test[Test]

    Start --> Understand
    Understand --> Pattern
    Pattern --> Design
    Design --> Implement
    Implement --> Test

    Check{Architecture Clear?}
    Understand --> Check
    Check -->|No| Understand
    Check -->|Yes| Pattern
```

### 8. **When Unsure**
- **Read files** before implementing
- **Ask user** if architecture is unclear
- **Check similar components** in the codebase
- **Use `read_file`** tool to examine existing code
- **Search codebase** for patterns: `grep -r "class.*Repository"`

### 9. **Examples from This Project**

#### ✅ Good: Understanding First
```dart
// 1. Read MessageRepository interface
// 2. See it uses MessageRemoteDataSource
// 3. Check MessageRemoteDataSource methods
// 4. Understand it works with MessageModel
// 5. Design sync service to use Repository (handles conversion)
```

#### ❌ Bad: Implementing Blind
```dart
// Created sync service using data sources directly
// Assumed getMessage() existed
// Mixed Models and Entities
// Got compilation errors
// Had to refactor
```

### 10. **Rule Application**

Apply this rule to:
- New services, repositories, data sources
- New features touching multiple layers
- Integration points between components
- Any time you're creating something that depends on existing code

**Remember**: 5 minutes of reading saves 30 minutes of refactoring.

## References
- [Clean Architecture](mdc:.cursor/rules/clean_architecture.mdc) (if exists)
- Project architecture docs in `docs/ARCHITECTURE.md`
